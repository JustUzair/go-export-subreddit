{
  "about": {
    "data": {
      "display_name": "golang",
      "public_description": "Ask questions and post articles about the Go programming language and related tools, events etc.",
      "header_title": "",
      "subscribers": 217780,
      "active_user_count": 531,
      "icon_img": "",
      "header_img": "https://b.thumbs.redditmedia.com/7BDtSXbohQaPFuaa6oCA5HtE53Flgld6rj3G7-TavDs.png"
    }
  },
  "posts": {
    "data": {
      "children": [
        {
          "data": {
            "id": "16ao61s",
            "selftext": "This post will be stickied at the top of [r/golang](https://www.reddit.com/r/golang/) until the last week of September (more or less).\n\nPlease adhere to the following rules when posting:\n\n**Rules for individuals:**\n\n* Don't create top-level comments; those are for employers.\n* Feel free to reply to top-level comments with on-topic questions.\n* Meta-discussion should be reserved for the distinguished mod comment.\n\n**Rules for employers:**\n\n* To make a top-level comment you must be hiring directly, or a focused third party recruiter with **specific jobs with named companies** in hand. No recruiter fishing for contacts please.\n* The job must involve working with Go on a regular basis, even if not 100% of the time.\n* One top-level comment per employer. If you have multiple job openings, please consolidate their descriptions or mention them in replies to your own top-level comment.\n* Please base your comment on the following template:\n\n**COMPANY:** *\\[Company name; ideally link to your company's website or careers page.\\]*\n\n**TYPE:** *\\[Full time, part time, internship, contract, etc.\\]*\n\n**DESCRIPTION:** *\\[What does your team/company do, and what are you using Go for? How much experience are you seeking and what seniority levels are you hiring for? The more details the better.\\]*\n\n**LOCATION:** *\\[Where are your office or offices located? If your workplace language isn't English-speaking, please specify it.\\]*\n\n**ESTIMATED COMPENSATION:** *\\[Please attempt to provide at least a rough expectation of wages/salary.If you can't state a number for compensation, omit this field. Do not just say \"competitive\". Everyone says their compensation is \"competitive\".If you are listing several positions in the \"Description\" field above, then feel free to include this information inline above, and put \"See above\" in this field.If compensation is expected to be offset by other benefits, then please include that information here as well.\\]*\n\n**REMOTE:** *\\[Do you offer the option of working remotely? If so, do you require employees to live in certain areas or time zones?\\]*\n\n**VISA:** *\\[Does your company sponsor visas?\\]*\n\n**CONTACT:** *\\[How can someone get in touch with you?\\]*",
            "author": "jerf",
            "title": "Who's Hiring? - September 2023",
            "subreddit_name_prefixed": "r/golang",
            "ups": 15,
            "created": 1693920210.0,
            "num_comments": 15,
            "url": "https://www.reddit.com/r/golang/comments/16ao61s/whos_hiring_september_2023/",
            "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/",
            "comments": [
              [
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/",
                          "body": "",
                          "id": "16ao61s",
                          "url": "https://www.reddit.com/r/golang/comments/16ao61s/whos_hiring_september_2023/"
                        }
                      }
                    ]
                  }
                },
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/jz8ave5/",
                          "body": "**META** Please post anything that isn't a job listing as a reply to this comment.\n\nAlso, I ask that you not downvote job submissions because of your opinion of the company.\n\n[August postings](https://www.reddit.com/r/golang/comments/15fidyp/whos_hiring_august_2023/).",
                          "id": "jz8ave5",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/jz8y4jn/",
                          "body": "**COMPANY:** [Prequel](https://www.prequel.co/)\n\n**TYPE:** Full time\n\n**DESCRIPTION:** Prequel is an API that makes it easy for B2B companies to sync data directly to their customer's data warehouse, on an ongoing basis.We're a tiny team of four engineers based in NYC. We're solving a number of hard technical problems that come with syncing tens of billions of rows of data every day with perfect data integrity: building reliable \u0026amp; scalable infrastructure, making data pipelines manageable without domain expertise, and creating a UX that abstracts out the underlying complexity to let the user share or receive data. We're powering this feature at companies like LogRocket, Modern Treasury, Postscript, and Metronome.\n\nOur stack is primarily K8s/Postgres/DuckDB/Golang/React/Typsecript and we support deployments in both our public cloud as well as our customers' clouds. Due to the nature of the product, we work with nearly every data warehouse product and most of the popular RDBMSs.\n\nWe're looking for a full stack engineer who can run the gamut from CI to UI. If you are interested in scaling infrastructure, distributed systems, developer tools, or relational databases, we have a lot of greenfield projects in these domains. We want someone who can humbly, but effectively, help us keep pushing our level of engineering excellence. We're open to those who don't already know our stack, but have the talent and drive to learn.\n\n**ESTIMATED COMPENSATION:**\\- Salary range for this band is $150K to $180K- Full healthcare benefits (medical, dental, vision), modern parental leave policies, and 401(k)- Perks including CitiBike membership \u0026amp; stipend for gym membership or art classes- Company culture focused on curiosity, learning, mentorship, and ownership\n\n**REMOTE:** No, NYC only\n\n**VISA:** Yes to [TN visa](https://travel.state.gov/content/travel/en/us-visas/employment/visas-canadian-mexican-nafta-professional-workers.html)**,** otherwise, Prequel does not sponsor visas at this time\n\n**CONTACT:**  To apply -- email [jobs@prequel.co](mailto:jobs@prequel.co) and include \\[Reddit\\] in the subject line",
                          "id": "jz8y4jn",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/jzjejrc/",
                          "body": "**COMPANY**: [Integrate](https://www.linkedin.com/company/integrate-program-logistics) and [Job Posting](https://jobs.gusto.com/postings/integrate-space-corporation-senior-full-stack-engineer-524afb85-40b7-44ae-b44c-9f4e57b34c85)\n\n**TYPE**: Full Time\n\n**DESCRIPTION**: Integrate is building program management software for the world’s most ambitious machines. Our core application focuses on cross-organizational collaboration, program management, and requirements tracking and is helping people get their products to market more simply and efficiently. We're looking for an experienced Golang developer who's not allergic to JavaScript (React). Our backend portions of our application (API and microservices) are written in Golang and this candidate would ideally be comfortable owning portions of this stack.\n\n**LOCATION**: US Remote / Seattle\n\n**ESTIMATED COMPENSATION**: $120,000 - $140,000, range negotiable and significant equity stake is available on top of base pay. \n\n**REMOTE**: yes, must be within the United States\n\n**VISA**: no\n\n**CONTACT**: Apply via the Job Posting link above",
                          "id": "jzjejrc",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/jzkh60y/",
                          "body": "COMPANY: [MedBridge](https://recruiting.paylocity.com/recruiting/jobs/All/235886f5-63d7-4b56-883a-0fbad71bff8b/MedBridge-Inc)  \nTYPE: Full time  \nDESCRIPTION: MedBridge is a dynamic software company working with the country’s largest healthcare providers to build technology solutions helping patients get better faster, while decreasing the overall cost of care.   \nLOCATION: Our Engineering team is growing and looking for a Software Engineer II \u0026amp; III to join us! We hire in the following states: AZ, CO, FL, IL, MA, MI, MN, NC, NY, OR, PA, TX, UT, VA, WA, WI, TN, KS.  \nESTIMATED COMPENSATION: \n\nSalary range for Software Engineer II is $110K to $140K\n\nSalary range for Software Engineer III is $130K to $175K\n\nFull healthcare benefits (medical, dental, vision), modern parental leave policies, and 401(k), stipend towards continuing education  \nREMOTE: completely remote  \nVISA:We donot sponsor visas or work with any C2C  \nCONTACT: please apply directly on the career's page.",
                          "id": "jzkh60y",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/jzv0u9n/",
                          "body": "**COMPANY:** [Passport, Inc](https://www.passportinc.com/)\n\n**TYPE:** Full Time\n\n**DESCRIPTION:** Passport, Inc provides a platform for parking and mobility. The role is for a backfill for myself as a [Software Engineering Manager, Mobile](https://workforcenow.adp.com/mascsr/default/mdf/recruitment/recruitment.html?cid=defb40d0-f2ac-46a8-a5c8-84f563616cc8\u0026amp;ccId=19000101_000001\u0026amp;jobId=474315\u0026amp;lang=en_US). That by itself is mobile development and not directly related to Go. However, I started an initiative to write a business logic layer for our mobile applications in Go using Go Mobile and update our native apps to use that library while using Swift UI and Jetpack Compose for UI over top of the Go Mobile library. The apps themselves are a mature project, but building a platform-agnostic library with Go is a greenfield effort. This role would be able to champion the project by providing technical expertise, guidance, and engineering. The team is eager but new to Go, so defining how the library goes about what it needs to do would be largely up to this person.\n\nThe role is an Engineering Manager position, and as such this person would be the quarterback of the team. You would work with product managers, solution architects, business analysts, and product owners to define and break down work for the team. While we are just starting to look at using Go, this role has the opportunity to make it a more central focus for themselves and the rest of the mobile team. Passport does expect Engineering Managers to be able to be hands on as time permits.\n\n**LOCATION:** Charlotte, NC\n\n**REMOTE:** Yes. As far as I know, there are no time zone requirements, but I believe current employees are either in the USA or India.\n\n**VISA:** Passport does not sponsor visas at this time\n\n**CONTACT:** Please apply directly on the [careers page](https://workforcenow.adp.com/mascsr/default/mdf/recruitment/recruitment.html?cid=defb40d0-f2ac-46a8-a5c8-84f563616cc8\u0026amp;ccId=19000101_000001\u0026amp;jobId=474315\u0026amp;lang=en_US)",
                          "id": "jzv0u9n",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16ao61s/whos_hiring_september_2023/k0g8esn/",
                          "body": "**Company**: Stream. [https://getstream.io/](https://getstream.io/)\n\n**Type**: Full-time (EU)\n\n**Description**: Stream is an API for building activity feeds, chat and live video. We do this for thousands of apps and over a billion end users. 4-5 years ago we switched from Python to Go and everything (other than ML) runs on Go, RocksDB, Raft, Redis, and CockroachDB/Postgres.  \n\n\nA few highlights:  \n\\* High traffic environment, focus on scalability  \n\\* 3 different products, each with their unique challenges. Activity feeds is very storage intensive with a fanout on read + fanout on write implementation. Video requires efficient Go code to ensure low CPU usage and low latency for video. Chat requires a good understanding of databases and denormalizing data, with some parts of chat like unread counts being storage-intensive  \n\\* At the moment we're hiring staff engineers in the EU remote as well as Amsterdam in the office.   \n\\* Candidates coming from a different language/background will also be considered. IE it's ok if you have only a bit of Go experience, but have been a backend staff level engineer or higher for years  \n\n\nEngineers at Stream tend to work very independently. More customer and product ownership compared to many other companies (our customers are engineers and product owners, so naturally engineers have more influence)  \n\n\n**Compensation**: Depends on experience, $100k-$140k  \n\n\n**How to learn more**: https://getstream.io/team/",
                          "id": "k0g8esn",
                          "url": ""
                        }
                      }
                    ]
                  }
                }
              ]
            ]
          }
        },
        {
          "data": {
            "id": "16k75nx",
            "selftext": "https://github.com/redis/rueidis/releases/tag/v1.0.18\n\nrueidis is an official Redis client library featured with low latencies by client-side caching and high throughputs by auto pipelining.\n\nIn the latest v1.0.18 release, we have fixed a year-long developer experience issue that makes the command builder of rueidis awkward in vscode. Now, vscode developers can fully enjoy the auto-completion of command builder as well!",
            "author": "rueian00",
            "title": "rueidis v1.0.18: improving developer experience in vscode",
            "subreddit_name_prefixed": "r/golang",
            "ups": 5,
            "created": 1694869637.0,
            "num_comments": 0,
            "url": "https://www.reddit.com/r/golang/comments/16k75nx/rueidis_v1018_improving_developer_experience_in/",
            "permalink": "/r/golang/comments/16k75nx/rueidis_v1018_improving_developer_experience_in/",
            "comments": [
              [
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k75nx/rueidis_v1018_improving_developer_experience_in/",
                          "body": "",
                          "id": "16k75nx",
                          "url": "https://www.reddit.com/r/golang/comments/16k75nx/rueidis_v1018_improving_developer_experience_in/"
                        }
                      }
                    ]
                  }
                },
                {
                  "data": {
                    "children": []
                  }
                }
              ]
            ]
          }
        },
        {
          "data": {
            "id": "16k8y46",
            "selftext": "Hello everyone. I am using kafka as messaging queue in my personal project. The goal is to use the [Transactional API](https://pkg.go.dev/github.com/confluentinc/confluent-kafka-go/v2/kafka#hdr-Transactional_producer_API) from [Confluent kafka library](https://pkg.go.dev/github.com/confluentinc/confluent-kafka-go/v2/kafka)  I am using multiple goroutines(most likely 5) to initiate multiple instances of consumer producer pair for each transaction. \n\nIn each transaction, the consumer reads a batch of messages, process the messages according to some logic and produces the appropriate response messages.\n\nIs the above method safe to use concurrently?  As I am getting duplicate records passed down to the next topic.\n\n\u0026amp;#x200B;\n\nPS: I am using an idempotent producer with following consumer config:\n\n    cosumerConfigMap := \u0026amp;kafka.ConfigMap {\n        \"group.id\": \"sample-id\",\n        \"auto.offset.reset\": \"earliest\",\n        \"enable.auto.commit\": \"false\",\n        \"isolation.level\": \"read_committed\",\n        \"group.instance.id\": \"unique-id\"\n    }\n\n\u0026amp;#x200B;",
            "author": "thisis_not_a_name",
            "title": "Confluent kafka transaction api with multiple go routines",
            "subreddit_name_prefixed": "r/golang",
            "ups": 3,
            "created": 1694874613.0,
            "num_comments": 0,
            "url": "https://www.reddit.com/r/golang/comments/16k8y46/confluent_kafka_transaction_api_with_multiple_go/",
            "permalink": "/r/golang/comments/16k8y46/confluent_kafka_transaction_api_with_multiple_go/",
            "comments": [
              [
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k8y46/confluent_kafka_transaction_api_with_multiple_go/",
                          "body": "",
                          "id": "16k8y46",
                          "url": "https://www.reddit.com/r/golang/comments/16k8y46/confluent_kafka_transaction_api_with_multiple_go/"
                        }
                      }
                    ]
                  }
                },
                {
                  "data": {
                    "children": []
                  }
                }
              ]
            ]
          }
        },
        {
          "data": {
            "id": "16k2bc3",
            "selftext": "Hey everyone, I’m a student of computer science, my primary language at the moment is C++, I have been coding basics in it for past few months, but I’m trying to go steps further to learn all the core functionalities such as pointers, refs, multi threading and everything, my goal is to move into golang in future, the only particular reason of me sticking with c++ is that I’m trying to get to the data structures part, and I heard it’s the best language out there to get the “low level learning” into your bone.\n\nShould I skip and start with golang? Or grasp the fundamentals of low level with c++ and then move to golang?\n\n\nAlso can you guys suggest some of the best sources to learn about golang in future and what type of projects and stuff a begginer should make at the beginning?\n\nThanks",
            "author": "NehadBaloch",
            "title": "C++ to Golang? Worth it?",
            "subreddit_name_prefixed": "r/golang",
            "ups": 6,
            "created": 1694853455.0,
            "num_comments": 46,
            "url": "https://www.reddit.com/r/golang/comments/16k2bc3/c_to_golang_worth_it/",
            "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/",
            "comments": [
              [
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/",
                          "body": "",
                          "id": "16k2bc3",
                          "url": "https://www.reddit.com/r/golang/comments/16k2bc3/c_to_golang_worth_it/"
                        }
                      }
                    ]
                  }
                },
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0tc08p/",
                          "body": "I've used C and C++ in previous jobs and GO is very much more in the C camp. It's basically a modern version of C which I personally love.",
                          "id": "k0tc08p",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0tdhiq/",
                          "body": "If learning the \"low level\" parts is your goal, then I would recommend concentrating on C plus some assembler, and pair that with a modern \"memory safe\" garbage collected language like Go, Java, C#, TypeScript etc. Chances are that you'll be using one of these higher level languages in the future in a job. I say \"garbage collected\" as a dividing line because in non-GC languages you have to spend a lot time either learning how to use the memory facilities or learning strategies to cope with a lack of memory facilities (i.e. C).\n\nC++ is a huge and complex mountain to climb (and they are building more mountain every few years). I don't recommend it as a general purpose language in the year 2023. There are certainly application domains where you need to know C++, but you would first need to have a desire to work in one of those domains.",
                          "id": "k0tdhiq",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0thxdo/",
                          "body": "\u0026gt; Should I skip and start with golang? Or grasp the fundamentals of low level with c++ and then move to golang?\n\nLearn C. Then go.\n\nLeave C++ for later, if you want to learn a more complex language that supports many programming paradigms (procedural, OOP, templates).",
                          "id": "k0thxdo",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0ucuw9/",
                          "body": "Speaking as someone who learned both C++ and Go from scratch If you wanna learn just learn it. I don’t think optimal sequencing matters so much as being determined enough to slog through the learning curve.",
                          "id": "k0ucuw9",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0tkxhw/",
                          "body": "I wrote C before, then switched to golang, after writing projects with golang for a few years, I integrated my experience of developing projects using go into a tool sponge, which made it easier and more efficient for me to develop complete projects, if you are interested, you can learn more about this tool, I hope it can help you.\n\n[https://github.com/zhufuyi/sponge](https://github.com/zhufuyi/sponge)",
                          "id": "k0tkxhw",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0u6ppp/",
                          "body": "Learn all the languages. By the end of your career you'll know dozens, including a few that don't exist yet. All your tools will change every few years. That's just the way things work.\n\nThe point is, there's no need to pick one and stick with just that. Master the ones you use for your schoolwork, and I mean really deeply understand inside and out, and find ones that pique your fancy and learn those as well. And try to learn at least one from each of these categories:\n\n* Low level: C, C++, Assembler\n* GC and/or Object oriented: Java, Go, C#\n* Functional: Lisp, ML, Haskell\n* Something web based: Javascript, Typescript\n* Something scripty: Bash, Python, Perl\n* Useful text processing utilities: sed, awk\n* Some new hotness: Rust, zig",
                          "id": "k0u6ppp",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0uhrho/",
                          "body": "What does c++ have to do with being a good software engineer? C++ also is NOT low level (that’s C).\n\nC++ is an ungodly contraption, by admission of its own creator, Stroustrup, which grew by accretion by piling up “fixes” upon f-ups created by wanting to be the latest modernest language for DECADES.\nThe syntax will make you puke, you can redefine the basic operators of the language like +, it’s theoretically got a type system and advanced memory  management, yet you do memory overruns all the time, the build system looks like it was made as a an April fool prank, the “many libraries” are from the 80s etc.\n\nYou basically said “I want to become a Tesla driver by learning on a 1950 Chevrolet so I know how a carburetor works”.\n\nI think what you wanted to say is:\n\n- I want to learn the basics of C to understand some fundamentals like cpu, memory, addresses, bit arithmetic\n- I want to learn algorithms by coding in python on leetcode\n- I want to read “Design Patterns” to have an idea of fundamental OO patterns, while being conscious of the fact the some of them (not all) have miserably failed, like inheritance or singleton\n- I want to learn go and rust to learn modern high performance backend languages\n- i then want to learn all the rest,?like containers, DBs, shell programming…, which all are language-independent things",
                          "id": "k0uhrho",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0u2ixd/",
                          "body": "Go lacks the rich standard library C++ provides. Learning DSA should probably be your number one priority right now and C++ is going to have an answer for everything DSA. You need this to get a job, likely even if that job is using Go day to day. Leetcoding in Go as your first language would be a mistake. I suggest learning C++ in small bites and using it to solve leetcode like questions. Maybe write some small projects like a simple multithreaded server in C++ too, and you will see all of the core concepts come up. Once you’re on your feet, work on some projects in Go and you will see the power of the abstraction. But please don’t shoot yourself in the foot by hard swapping to Go. If you must, at least learn Python at the same time.",
                          "id": "k0u2ixd",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0tizwy/",
                          "body": "For learning fundamentals i think c++ is good and go is good as well. I  wonder why you want to pick go specifically for? If you are interested in building something in the future and perhaps follow it up with a high potential of getting a job then i would suggest for web development learn JavaScript or php or if you want to venture into other areas then there are many other options as well. Good luck friend.",
                          "id": "k0tizwy",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0tlsec/",
                          "body": "I would stick with C++ for the time being. You can't learn all of it but having a decent background in C++ will help you a lot in your professional life. It can be a hiring reason. You can learn Go very easily and fast later.",
                          "id": "k0tlsec",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0toavi/",
                          "body": "All programming languages are tools, and some are better at different things than others.  Which language you choose should be dependent on the task and your goals.\n\n\u0026gt; learn all the core functionalities such as pointers, refs, multi threading and everything\n\nIf this is your goal, then I would continue to stick with C or C++ for the time being.  Go hides some of those things from the user to make coding easier.  This is great if you're trying to get something done and make money with it, but less great if you really want to play with those items to learn them.",
                          "id": "k0toavi",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0tvuff/",
                          "body": "Good for you, golang is a good choice for backend. I am currently working on the backend  in golang. So many components was written by golang, such as etcd and docker, but my favorite program language is still c++.",
                          "id": "k0tvuff",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0twdzg/",
                          "body": "Best sources for learning Go is definitely checking other repositories and learning how others build there Go projects. And of course, write your own project from it. \n\nGood thing with Go is it’s very easy and fast to get productive in it so you can still learn C++ (harder language) while doing Go lang projects.",
                          "id": "k0twdzg",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0u28kl/",
                          "body": "Think of \"knowing to program in a certain language\" as a tool in a toolbox. The more you have and the better they are, the more flexible you are in solving a problem.",
                          "id": "k0u28kl",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0u6lyu/",
                          "body": "You can stick with C++ as long as you want. It does give you low level knowledge that you won't find programming in other modern languages (Go included). And with C++ experience you can pick up Go in a weekend.\n\nAs for projects, I suggest implementing an in-memory store a la [Redis](https://redis.io). It's going to showcase Go concurrency features really well.",
                          "id": "k0u6lyu",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0ud9f7/",
                          "body": "I spent a good number of years on C++ and C# before switching to Go in 2016 and I haven't looked back. Now, it really depends on what kind of software you'd like to work on because any general purpose programming language is just a tool at the end of the day. I suggest you browse some of the \"awesome lists\" on GitHub for topics that you're interested in to see what languages are being used for those things and how so you'll know what to focus on. For example, I'm perfectly happy with Go right now because my current job and the previous 2 required me to work on Cloud infrastructure microservices and Go shines in that space. Now I'm looking to get into computational biology and, while I can find a few places where people started using Go in this space, I really need to get a better grasp of Python and R at the very least because they have a lot of libraries for data visualisation and statistics that I'll need to use.",
                          "id": "k0ud9f7",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0udp6y/",
                          "body": "If you learn C++ fully, you should be able to pick up go in about 2 weeks. One of the design goals of the language is for it to be easy to pick up.\n\nHowever, in my opinion good engineers have a big toolbox, so here are some other recommendations of languages to help you be well rounded:\n\n* Python: Good for data analysis (by calling into C++) and scripting\n* Haskell or Ocaml: They will likely break your brain a bit, but with OOP and Procedural languages slowly taking more and more fp features, this will help a lot in learning more. \n* C: Being forced to work with almost no abstractions gives you a rich understanding of what you are actually doing. Also, everything eventually comes down to the C abi.\n* Javascript or Typescript: You will eventually need to do something in a browser\n* Coq or TLA+: Both of these languages have saved me months of debugging by showing that my design had a fundamental flaw. \n* Java or C#: Too much GC OOP code out there to not learn one of the two big languages.",
                          "id": "k0udp6y",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0ue2lz/",
                          "body": "Yes",
                          "id": "k0ue2lz",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0uf2z1/",
                          "body": "Through the various additions, revisions and extensions to the C++ language specs through the years it's become a difficult to learn and cluttered language, if it ever was easy to grasp in the first place. If you're looking for low level \u0026amp; performance, I'd rather go with Rust.\nGo is a language that by its radical simplicity, hassle-free memory safety and built-in concurrency is predestined to be used for writing cloud services, and that seems to be its main application.\n\nI don't think there's one language for every purpose. So I'd rather ask what you wanna do and than make an informed choice.",
                          "id": "k0uf2z1",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0uq0ab/",
                          "body": "Try rust :)",
                          "id": "k0uq0ab",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0uqaea/",
                          "body": "C++ is great to learn on but I don't believe you know C++ like what people use today.  It's a different beast in production and the only reason I would encourage it's continued use is if you want to: make video games, design RTC's, or work with hardware.  Otherwise, go with Go or Rust, and I would venture to say just work with both.  Rust will look like C++ but act like a snobby poet.  Go will look like Python but it's a workhorse of a gerbal ;=\n\nGo\n\nPros:\n\nEasy syntax\n\nbuilt-in concurrency\n\nnaturally blocking\n\nsupports message passing between channels\n\noffers great libraries from a dedicated language team\n\nNative lang to extend Docker, k8s, etc.\n\nYou'll be ahead of most students going the spring route\n\n\u0026amp;#x200B;\n\nCons:\n\nEverybody who is a decent programmer can learn it\n\neasy to write, hard to keep memory usage down\n\nbad Go invokes the tri-color GC, which hurts perf\n\neasy to write poorly\n\nConfusing concepts around certain instantiations\n\n\u0026amp;#x200B;\n\nRust\n\nPros:\n\nGreat job market for competent devs\n\nmemory-safety\n\ngreat web server options\n\npattern matching\n\nnative linking with C++ and C\n\nCompiler teaches you how to write code\n\nGreat toolchain\n\nWorks on hardware without using \"unsafe\" or \"volatile\" libs\n\npetaflop club\n\nOutstanding crates (libs) to pull in\n\nEveryone who writes it professionally does a good job of writing good code.\n\n\u0026amp;#x200B;\n\nCon:\n\nImmature ecosystem\n\nhard to troubleshoot web development\n\nTerse Syntax\n\nHuge learning curve\n\nPainting yourself into a corner\n\nDifficult to discern what's good abstraction\n\nHard to write good Rust\n\nNo concurrency built in and Async libs or QoL features are community written and community driven.\n\n\u0026amp;#x200B;\n\nRust has a better transition with C++ and you will most likely work on code bases that integrate with it most likely.  Either as a core integration or a future full drop-in replacement.  Go is not going to benefit any deep C++ knowledge, you'll get used to some of the message passing ideas, and have a great handle on pointers but it won't be a huge benefit.  In addition, there are things in Rust that you can't do in Golang, which make the language less like C and more like low memory footprint Python.  However, these restrictions put you into a box, which helps support writing better code.  One example is this:\n\ni  = \\* ( long \\* ) \\\u0026amp;y;\n\n\u0026amp;#x200B;\n\nwhich is considered type juggling, which was part of Quake III's original code: [https://en.wikipedia.org/wiki/Fast\\_inverse\\_square\\_root](https://en.wikipedia.org/wiki/Fast_inverse_square_root)\n\nDoing this operation is dangerous and can only work within a controlled environment like taking the inverse square root.  However, if you were to write this code for a military RTC, you could get written up haha, jk.  It's just a dangerous operation but these are the qualities that make some games smooth and stable for certain features like physics.\n\nTherefore, in C++ you'll be able to write jenky, hacker code to get speed results, which makes your paychecks better.  As long as you can test the daylights out of it and prove it's stable, then you'll go extremely far, especially with DoD private contractors.\n\nHowever, do you want to write code that gets the speed results but sacrifices security and safety?  It's better to err on the side of caution and pursue the future of programming, which is Go and Rust.  if you want to learn C++, then go to C++11 and learn the STL, go to C++14, learn all of the core features, go to C++17 and read up on the updates, then start writing systems in it.  There's C++20 \u0026amp; C++23 but it's a language notorious for breaking changes when upgrading, so you'll most likely get used to a certain distribution of it and apply for those jobs mainly.  You could get a job anywhere probably with good C++11 but knowing the history and updates, make it easier to market yourself.",
                          "id": "k0uqaea",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0us1or/",
                          "body": "\u0026gt; and I heard it’s the best language out there to get the “low level learning”\n\nYou might want to reconsider where and when you open your ears. Modern C++ is a major pita. And: What type of \"low level\" are you taking about? Hardware? Machine Language? Algorithms?",
                          "id": "k0us1or",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16k2bc3/c_to_golang_worth_it/k0utv3n/",
                          "body": "Not to say that go is a bad language, but if you want to learn the concepts, Rust is a much better choice than go",
                          "id": "k0utv3n",
                          "url": ""
                        }
                      }
                    ]
                  }
                }
              ]
            ]
          }
        },
        {
          "data": {
            "id": "16jnl1f",
            "selftext": "Hello everyone. I've been writing Go for over 1.5 years now (Non professionally. For my side projects only). Ive started reading \"writing an interpreter in Go\". Im writing code along with reading. Im almost at the bottom of parser. I understood Lexer, Tokenizer, AST like it was nothing. But parser... oh man I don't understand sh*t. The author did a great job explaining everything. But when I get everything around my head, wake up the next day and boom, I forgot everything. Im not sure if its because the parser part is hardest or im just way too dumb to understand. Im thinking about finishing the book, playing with the codebase for few days trying to implement new features and revise the parser part. I really love the book and want to get the best out of it. Didn't touch evaluation part yet, so im not sure if its even harder or not.\n\nNote: I have just finished high school and didn't get into college yet so I had no knowledge over how interpreter works in general.",
            "author": "KledMainSG",
            "title": "Is Writing an interpreter with go hard or im just dumb. Need motivation.",
            "subreddit_name_prefixed": "r/golang",
            "ups": 53,
            "created": 1694808893.0,
            "num_comments": 25,
            "url": "https://www.reddit.com/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/",
            "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/",
            "comments": [
              [
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/",
                          "body": "",
                          "id": "16jnl1f",
                          "url": "https://www.reddit.com/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/"
                        }
                      }
                    ]
                  }
                },
                {
                  "data": {
                    "children": [
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0qyeao/",
                          "body": "Parsing is hard. Perhaps surprisingly, it is a problem in the field of compilers that is not necessarily \"solved\"; that is to say, people knowledgeable in the field continue to debate the best way to approach the problem. There is not one agreed-upon solution that simply everyone uses. Indeed, most \"real\" parsers in the world are often hand-written hybrids of quite a few approaches.\n\nI do not know what the book \"Writing an Interpreter for Go\" goes over, but a traditional parser introduction you can find a lot of information about online is to write a simple mathematical expression evaluator that allows `+`, `-`, `*`, `/`, and parentheses, and honors order-of-operations. If you've got lexing and tokenizing down, this is sort of the smallest possible instance of the problem. You can bootstrap up from there by allowing other functions, working your way to defining functions that can be used by future expressions, etc.\n\nFor me personally, what stuck the best was [parser combinators](https://pkg.go.dev/github.com/prataprc/goparsec#section-readme), though those often incorporate lexing as well, but your mileage may vary. (It flows better in Haskell than it does in Go.) It felt more direct than the approach a lot of parsers take of specifying a parse in some custom language as a separate blob that is hard to understand because of all the indirection in the code that implements the parse specification. That project has some blog posts which I'd recommend, and I'd also recommend using a debugger to [step through the expr tests](https://github.com/prataprc/goparsec/blob/master/expr/expr_test.go), slowly, and making sure you understand each step. Parser combinators are nice in that you can actually follow the flow between the library code and the code you wrote with a debugger; if you're lost in the library, hang on a moment and it should be calling back into your code shortly.",
                          "id": "k0qyeao",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0rll9t/",
                          "body": "It's not hard, it just looks hard. That is, seeing how to write a parser is hard, but once you know how it's remarkably simple. It took me a while to learn that. I used to use tools like yacc, but then was told about the way a recursive descent parser mirrors the grammar perfectly. If you know how to write the EBNF for a grammar - which is not a priori obvious but is a skill deeply worth learning - the parser practically can write itself by just implementing the grammar. Sounds facile but it's not. \n\nHere are some examples from my own work. I do this kind of thing a lot, but that's because it's fun. Maybe my code will help you.\n\nHave a look at https://github.com/robpike/expr/blob/main/expr.go\n\nstarting around line 205. It's a recursive descent parser for Go's arithmetic expressions. it's a little odd because the lexer is kinda embedded in the parser, but you should see what's going on. And it's _tiny_.\n\nOr look at https://github.com/robpike/ivy/blob/master/parse/parse.go starting at line 345, a more traditional version.\n\nPerhaps the cleanest of them all though is the constant evaluator in Go's assembler,\n\nhttps://github.com/golang/go/blob/master/src/cmd/asm/internal/asm/parse.go\n\nstarting at line 1238. It's a very clean expression of the technique. It's not perhaps obvious at first glance, but seeing how this implements operator precedence is a valuable exercise.\n\nOne important thing: you must be very comfortable with recursive programming to get this. Some people aren't, but parsing is one area where a grasp of how recursion works can illuminate everything.",
                          "id": "k0rll9t",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0r5icg/",
                          "body": "I agree with the other comment here: parsing is hard.\n\nWriting recursive descent parser is not trivial, and making sure it doesn't blow up with a combinatorial explosion is even harder. That's why I am on the side of using yacc (disclaimer: you can find a lot of anti-yacc sentiment in the internet; I don't know how to comment that; maybe it's just people who did not grasp the tool). When you have your grammar without conflicts, i's **guaranteed** to be parsed in linear time. That's a lot. As someone who already spent significant amount of time trying to get the parser right, I think you can appreciate the fact, that your yacc-generated LALR parser would be not only working, but also in *O(N)* time.\n\nGo has [goyacc](https://golang.org/x/tools/cmd/goyacc) and it's working well, though its documentation assumes you're already quite well versed with the original yacc. What I found useful at that stage was the original [Stephen Johnson's paper](https://www.cs.utexas.edu/users/novak/yaccpaper.htm) (he is The Author of the tool after all).\n\nHere is also an [example of using goyacc in a Go project](https://github.com/wkhere/bcl), together with a simple lexer descendant from quite known [Rob Pike's lexer](https://www.youtube.com/watch?v=HxaD_trXwRE) (btw, I recommend watching the latter, it's a pearl on its own..)",
                          "id": "k0r5icg",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0smbxs/",
                          "body": "Even I was not able to understand for first time so I took a break did some other projects and got full motivation to write a compiler in the second time I was able to grasp the concepts easily.",
                          "id": "k0smbxs",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0r4848/",
                          "body": "https://youtu.be/0iYokQi9mHg?si=7n5onFav5DVWf0aH here is a nice talk about simple DSL in go. \n\nI learned from it to write a BNF and then use a simple Lexer to create a parser for this BNF. It feels quite simple when you implement it that way.",
                          "id": "k0r4848",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0r8ctt/",
                          "body": "It's hard",
                          "id": "k0r8ctt",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0rrxdj/",
                          "body": "I read that book. I don't like the way he did the operator-precedence parsing using a Pratt parser. I would have just encoded the precedence in the grammar to make it easier to reason about.\n\nYeah parsing, especially recursive descent parsing, is one of those where if someone just sits down with you and guides you through the process, it'll just click and become easy. But it can become hard if you run into a new technique. It gets overwhelming quickly without gentle guidance.\n\nHere's a list of parsers from easiest to make to hardest.\n* Parser combinators \u0026lt;- You could have invented this yourself\n* Recursive descent\n* Pratt / operator precedence \u0026lt;- The example in the book\n* Table driven LL(k)\n* LALR and its ilk (table-driven bottom-up) \u0026lt;- From here on it's easier to make a program that generates the parsing code for you because it's easier to reason about a parser generator than the parser itself\n* GLR / concurrent parsers of ambiguous grammars",
                          "id": "k0rrxdj",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0sno63/",
                          "body": "For the purposes of learning to write an interpreter, Go is on pretty equal footing with just about any other widely-used language. If you want to write an interpreter that'll be used for real work, Go is a fairly poor choice because Go's memory paradigms will make it difficult to manage the interpreted program's stack without a bunch of heap-allocated overhead or performance penalties from going in and out of cgo.",
                          "id": "k0sno63",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0rgbhj/",
                          "body": "Just curious about something.. side context to this.. but code formatters.. do they use an AST approach as well and \"rewrite\" the source in format? Or do they just do some basic parsing of the language and adjust tabs/spaces, etc? Was curious why it seems so hard to find good code formatters. In particular you would think there could be a fairly universal tool that works across multiple languages with templates and options (like tabs for spaces, lines after { } and so on.",
                          "id": "k0rgbhj",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0qwkrx/",
                          "body": "[deleted]",
                          "id": "k0qwkrx",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0rmlk2/",
                          "body": "The easiest parser is LL1. You can write a LL1 parser in recursive functions. Go get a dragon book. Forget about Go. It is fucking algorithm not implantation",
                          "id": "k0rmlk2",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0r7iav/",
                          "body": "[deleted]",
                          "id": "k0r7iav",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0taltl/",
                          "body": "The Lexer part was fine for me, I'm currently stuck on the Parser. I may get the big picture as I go along hopefully.",
                          "id": "k0taltl",
                          "url": ""
                        }
                      },
                      {
                        "Data": {
                          "permalink": "/r/golang/comments/16jnl1f/is_writing_an_interpreter_with_go_hard_or_im_just/k0ukcvo/",
                          "body": "https://craftinginterpreters.com/parsing-expressions.html\n\nHere is a great book I can only recommend. Hopefully it helps you proceed on your way to understand parsers better.",
                          "id": "k0ukcvo",
                          "url": ""
                        }
                      }
                    ]
                  }
                }
              ]
            ]
          }
        }
      ]
    }
  }
}